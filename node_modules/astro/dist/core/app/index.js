import mime from "mime";
import { attachToResponse, getSetCookiesFromResponse } from "../cookies/index.js";
import { callEndpoint } from "../endpoint/index.js";
import { consoleLogDestination } from "../logger/console.js";
import { error } from "../logger/core.js";
import { prependForwardSlash, removeTrailingForwardSlash } from "../path.js";
import { RedirectSinglePageBuiltModule } from "../redirects/index.js";
import {
  createEnvironment,
  createRenderContext,
  tryRenderPage
} from "../render/index.js";
import { RouteCache } from "../render/route-cache.js";
import {
  createAssetLink,
  createModuleScriptElement,
  createStylesheetElementSet
} from "../render/ssr-element.js";
import { matchRoute } from "../routing/match.js";
import { deserializeManifest } from "./common.js";
const clientLocalsSymbol = Symbol.for("astro.locals");
const responseSentSymbol = Symbol.for("astro.responseSent");
class App {
  /**
   * The current environment of the application
   */
  #env;
  #manifest;
  #manifestData;
  #routeDataToRouteInfo;
  #encoder = new TextEncoder();
  #logging = {
    dest: consoleLogDestination,
    level: "info"
  };
  #baseWithoutTrailingSlash;
  constructor(manifest, streaming = true) {
    this.#manifest = manifest;
    this.#manifestData = {
      routes: manifest.routes.map((route) => route.routeData)
    };
    this.#routeDataToRouteInfo = new Map(manifest.routes.map((route) => [route.routeData, route]));
    this.#baseWithoutTrailingSlash = removeTrailingForwardSlash(this.#manifest.base);
    this.#env = this.#createEnvironment(streaming);
  }
  set setManifest(newManifest) {
    this.#manifest = newManifest;
  }
  /**
   * Creates an environment by reading the stored manifest
   *
   * @param streaming
   * @private
   */
  #createEnvironment(streaming = false) {
    return createEnvironment({
      adapterName: this.#manifest.adapterName,
      logging: this.#logging,
      markdown: this.#manifest.markdown,
      mode: "production",
      compressHTML: this.#manifest.compressHTML,
      renderers: this.#manifest.renderers,
      clientDirectives: this.#manifest.clientDirectives,
      resolve: async (specifier) => {
        if (!(specifier in this.#manifest.entryModules)) {
          throw new Error(`Unable to resolve [${specifier}]`);
        }
        const bundlePath = this.#manifest.entryModules[specifier];
        switch (true) {
          case bundlePath.startsWith("data:"):
          case bundlePath.length === 0: {
            return bundlePath;
          }
          default: {
            return createAssetLink(bundlePath, this.#manifest.base, this.#manifest.assetsPrefix);
          }
        }
      },
      routeCache: new RouteCache(this.#logging),
      site: this.#manifest.site,
      ssr: true,
      streaming
    });
  }
  set setManifestData(newManifestData) {
    this.#manifestData = newManifestData;
  }
  removeBase(pathname) {
    if (pathname.startsWith(this.#manifest.base)) {
      return pathname.slice(this.#baseWithoutTrailingSlash.length + 1);
    }
    return pathname;
  }
  match(request, { matchNotFound = false } = {}) {
    const url = new URL(request.url);
    if (this.#manifest.assets.has(url.pathname)) {
      return void 0;
    }
    let pathname = prependForwardSlash(this.removeBase(url.pathname));
    let routeData = matchRoute(pathname, this.#manifestData);
    if (routeData) {
      if (routeData.prerender)
        return void 0;
      return routeData;
    } else if (matchNotFound) {
      const notFoundRouteData = matchRoute("/404", this.#manifestData);
      if (notFoundRouteData == null ? void 0 : notFoundRouteData.prerender)
        return void 0;
      return notFoundRouteData;
    } else {
      return void 0;
    }
  }
  async render(request, routeData, locals) {
    let defaultStatus = 200;
    if (!routeData) {
      routeData = this.match(request);
      if (!routeData) {
        defaultStatus = 404;
        routeData = this.match(request, { matchNotFound: true });
      }
      if (!routeData) {
        return new Response(null, {
          status: 404,
          statusText: "Not found"
        });
      }
    }
    Reflect.set(request, clientLocalsSymbol, locals ?? {});
    if (routeData.route === "/404") {
      defaultStatus = 404;
    }
    let mod = await this.#getModuleForRoute(routeData);
    if (routeData.type === "page" || routeData.type === "redirect") {
      let response = await this.#renderPage(request, routeData, mod, defaultStatus);
      if (response.status === 500 || response.status === 404) {
        const errorRouteData = matchRoute("/" + response.status, this.#manifestData);
        if (errorRouteData && errorRouteData.route !== routeData.route) {
          mod = await this.#getModuleForRoute(errorRouteData);
          try {
            let errorResponse = await this.#renderPage(
              request,
              errorRouteData,
              mod,
              response.status
            );
            return errorResponse;
          } catch {
          }
        }
      }
      return response;
    } else if (routeData.type === "endpoint") {
      return this.#callEndpoint(request, routeData, mod, defaultStatus);
    } else {
      throw new Error(`Unsupported route type [${routeData.type}].`);
    }
  }
  setCookieHeaders(response) {
    return getSetCookiesFromResponse(response);
  }
  async #getModuleForRoute(route) {
    if (route.type === "redirect") {
      return RedirectSinglePageBuiltModule;
    } else {
      if (this.#manifest.pageMap) {
        const importComponentInstance = this.#manifest.pageMap.get(route.component);
        if (!importComponentInstance) {
          throw new Error(
            `Unexpectedly unable to find a component instance for route ${route.route}`
          );
        }
        const pageModule = await importComponentInstance();
        return pageModule;
      } else if (this.#manifest.pageModule) {
        const importComponentInstance = this.#manifest.pageModule;
        return importComponentInstance;
      } else {
        throw new Error(
          "Astro couldn't find the correct page to render, probably because it wasn't correctly mapped for SSR usage. This is an internal error, please file an issue."
        );
      }
    }
  }
  async #renderPage(request, routeData, page, status = 200) {
    const url = new URL(request.url);
    const pathname = prependForwardSlash(this.removeBase(url.pathname));
    const info = this.#routeDataToRouteInfo.get(routeData);
    const links = /* @__PURE__ */ new Set();
    const styles = createStylesheetElementSet(info.styles);
    let scripts = /* @__PURE__ */ new Set();
    for (const script of info.scripts) {
      if ("stage" in script) {
        if (script.stage === "head-inline") {
          scripts.add({
            props: {},
            children: script.children
          });
        }
      } else {
        scripts.add(createModuleScriptElement(script));
      }
    }
    try {
      const mod = await page.page();
      const renderContext = await createRenderContext({
        request,
        pathname,
        componentMetadata: this.#manifest.componentMetadata,
        scripts,
        styles,
        links,
        route: routeData,
        status,
        mod,
        env: this.#env
      });
      const response = await tryRenderPage(renderContext, this.#env, mod, page.onRequest);
      Reflect.set(request, responseSentSymbol, true);
      return response;
    } catch (err) {
      error(this.#logging, "ssr", err.stack || err.message || String(err));
      return new Response(null, {
        status: 500,
        statusText: "Internal server error"
      });
    }
  }
  async #callEndpoint(request, routeData, page, status = 200) {
    const url = new URL(request.url);
    const pathname = "/" + this.removeBase(url.pathname);
    const mod = await page.page();
    const handler = mod;
    const ctx = await createRenderContext({
      request,
      pathname,
      route: routeData,
      status,
      env: this.#env,
      mod: handler
    });
    const result = await callEndpoint(handler, this.#env, ctx, page.onRequest);
    if (result.type === "response") {
      if (result.response.headers.get("X-Astro-Response") === "Not-Found") {
        const fourOhFourRequest = new Request(new URL("/404", request.url));
        const fourOhFourRouteData = this.match(fourOhFourRequest);
        if (fourOhFourRouteData) {
          return this.render(fourOhFourRequest, fourOhFourRouteData);
        }
      }
      return result.response;
    } else {
      const body = result.body;
      const headers = new Headers();
      const mimeType = mime.getType(url.pathname);
      if (mimeType) {
        headers.set("Content-Type", `${mimeType};charset=utf-8`);
      } else {
        headers.set("Content-Type", "text/plain;charset=utf-8");
      }
      const bytes = this.#encoder.encode(body);
      headers.set("Content-Length", bytes.byteLength.toString());
      const response = new Response(bytes, {
        status: 200,
        headers
      });
      attachToResponse(response, result.cookies);
      return response;
    }
  }
}
export {
  App,
  deserializeManifest
};
