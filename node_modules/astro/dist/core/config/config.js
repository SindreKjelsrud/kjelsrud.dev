import * as colors from "kleur/colors";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath, pathToFileURL } from "node:url";
import { AstroError, AstroErrorData } from "../errors/index.js";
import { mergeConfig } from "./merge.js";
import { createRelativeSchema } from "./schema.js";
import { loadConfigWithVite } from "./vite-load.js";
const LEGACY_ASTRO_CONFIG_KEYS = /* @__PURE__ */ new Set([
  "projectRoot",
  "src",
  "pages",
  "public",
  "dist",
  "styleOptions",
  "markdownOptions",
  "buildOptions",
  "devOptions"
]);
async function validateConfig(userConfig, root, cmd) {
  const fileProtocolRoot = pathToFileURL(root + path.sep);
  if (userConfig.hasOwnProperty("renderers")) {
    console.error('Astro "renderers" are now "integrations"!');
    console.error("Update your configuration and install new dependencies:");
    try {
      const rendererKeywords = userConfig.renderers.map(
        (r) => r.replace("@astrojs/renderer-", "")
      );
      const rendererImports = rendererKeywords.map((r) => `  import ${r} from '@astrojs/${r === "solid" ? "solid-js" : r}';`).join("\n");
      const rendererIntegrations = rendererKeywords.map((r) => `    ${r}(),`).join("\n");
      console.error("");
      console.error(colors.dim("  // astro.config.js"));
      if (rendererImports.length > 0) {
        console.error(colors.green(rendererImports));
      }
      console.error("");
      console.error(colors.dim("  // ..."));
      if (rendererIntegrations.length > 0) {
        console.error(colors.green("  integrations: ["));
        console.error(colors.green(rendererIntegrations));
        console.error(colors.green("  ],"));
      } else {
        console.error(colors.green("  integrations: [],"));
      }
      console.error("");
    } catch (err) {
    }
    process.exit(1);
  }
  let legacyConfigKey;
  for (const key of Object.keys(userConfig)) {
    if (LEGACY_ASTRO_CONFIG_KEYS.has(key)) {
      legacyConfigKey = key;
      break;
    }
  }
  if (legacyConfigKey) {
    throw new AstroError({
      ...AstroErrorData.ConfigLegacyKey,
      message: AstroErrorData.ConfigLegacyKey.message(legacyConfigKey)
    });
  }
  const AstroConfigRelativeSchema = createRelativeSchema(cmd, fileProtocolRoot);
  const result = await AstroConfigRelativeSchema.parseAsync(userConfig);
  return result;
}
function resolveFlags(flags) {
  return {
    root: typeof flags.root === "string" ? flags.root : void 0,
    site: typeof flags.site === "string" ? flags.site : void 0,
    base: typeof flags.base === "string" ? flags.base : void 0,
    port: typeof flags.port === "number" ? flags.port : void 0,
    open: typeof flags.open === "boolean" ? flags.open : void 0,
    config: typeof flags.config === "string" ? flags.config : void 0,
    host: typeof flags.host === "string" || typeof flags.host === "boolean" ? flags.host : void 0,
    drafts: typeof flags.drafts === "boolean" ? flags.drafts : void 0,
    experimentalAssets: typeof flags.experimentalAssets === "boolean" ? flags.experimentalAssets : void 0,
    experimentalRedirects: typeof flags.experimentalRedirects === "boolean" ? flags.experimentalRedirects : void 0
  };
}
function resolveRoot(cwd) {
  if (cwd instanceof URL) {
    cwd = fileURLToPath(cwd);
  }
  return cwd ? path.resolve(cwd) : process.cwd();
}
function mergeCLIFlags(astroConfig, flags) {
  return mergeConfig(astroConfig, {
    site: flags.site,
    base: flags.base,
    markdown: {
      drafts: flags.drafts
    },
    server: {
      port: flags.port,
      host: flags.host,
      open: flags.open
    }
  });
}
async function search(fsMod, root) {
  const paths = [
    "astro.config.mjs",
    "astro.config.js",
    "astro.config.ts",
    "astro.config.mts",
    "astro.config.cjs",
    "astro.config.cts"
  ].map((p) => path.join(root, p));
  for (const file of paths) {
    if (fsMod.existsSync(file)) {
      return file;
    }
  }
}
async function resolveConfigPath(configOptions) {
  const root = resolveRoot(configOptions.cwd);
  const flags = resolveFlags(configOptions.flags || {});
  let userConfigPath;
  if (flags == null ? void 0 : flags.config) {
    userConfigPath = /^\.*\//.test(flags.config) ? flags.config : `./${flags.config}`;
    userConfigPath = fileURLToPath(new URL(userConfigPath, `file://${root}/`));
    if (!configOptions.fs.existsSync(userConfigPath)) {
      throw new AstroError({
        ...AstroErrorData.ConfigNotFound,
        message: AstroErrorData.ConfigNotFound.message(flags.config)
      });
    }
  } else {
    userConfigPath = await search(configOptions.fs, root);
  }
  return userConfigPath;
}
async function openConfig(configOptions) {
  const root = resolveRoot(configOptions.cwd);
  const flags = resolveFlags(configOptions.flags || {});
  const userConfig = await loadConfig(configOptions, root);
  const astroConfig = await resolveConfig(userConfig, root, flags, configOptions.cmd);
  return {
    astroConfig,
    userConfig,
    flags,
    root
  };
}
async function loadConfig(configOptions, root) {
  const fsMod = configOptions.fsMod ?? fs;
  const configPath = await resolveConfigPath({
    cwd: configOptions.cwd,
    flags: configOptions.flags,
    fs: fsMod
  });
  if (!configPath)
    return {};
  return await loadConfigWithVite({
    configPath,
    fs: fsMod,
    root
  });
}
async function resolveConfig(userConfig, root, flags = {}, cmd) {
  const mergedConfig = mergeCLIFlags(userConfig, flags);
  const validatedConfig = await validateConfig(mergedConfig, root, cmd);
  return validatedConfig;
}
function createDefaultDevConfig(userConfig = {}, root = process.cwd()) {
  return resolveConfig(userConfig, root, void 0, "dev");
}
export {
  LEGACY_ASTRO_CONFIG_KEYS,
  createDefaultDevConfig,
  openConfig,
  resolveConfig,
  resolveConfigPath,
  resolveFlags,
  resolveRoot,
  validateConfig
};
